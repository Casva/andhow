package org.yarnandtail.andhow.internal;

import java.io.*;
import java.lang.annotation.ElementType;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.annotation.processing.*;
import javax.lang.model.element.*;
import javax.tools.FileObject;
import org.yarnandtail.andhow.GlobalPropertyGroup;

/**
 *
 * @author ericeverman
 */
@SupportedAnnotationTypes("org.yarnandtail.andhow.GlobalPropertyGroup")
public class AndHowCompileProcessor extends AbstractProcessor {

	public static final String GENERATED_CLASS_PREFIX = "$GlobalPropProxy";
	public static final String GENERATED_CLASS_NESTED_SEP = "$";
	
	private static final String SERVICES_PACKAGE = "";
	private static final String RELATIVE_NAME = "META-INF/services/org.yarnandtail.andhow.PropertyGroup";

	//Static to insure all generated classes have the same timestamp
	private static Calendar runDate;

	public AndHowCompileProcessor() {
		//required by Processor API
		runDate = new GregorianCalendar();
	}

	@Override
	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {

		Filer filer = this.processingEnv.getFiler();
		Set<? extends Element> globalGroups = roundEnv.getElementsAnnotatedWith(GlobalPropertyGroup.class);

		if (globalGroups != null && globalGroups.size() > 0) {
			trace("Found " + globalGroups.size() + " global property groups based on annotations");

			StringBuffer existingServiceFileContent = new StringBuffer();
			StringBuffer newServiceFileContent = new StringBuffer();

			try {

				FileObject groupFile = filer.getResource(
						javax.tools.StandardLocation.SOURCE_OUTPUT,
						SERVICES_PACKAGE, RELATIVE_NAME);

				if (groupFile != null) {
					existingServiceFileContent.append(groupFile.getCharContent(true));
				}

			} catch (IOException ex) {
				//Ignore - This just means the file doesn't exist
			}

			for (Element e : globalGroups) {

				if (e.getKind().equals(ElementKind.INTERFACE)) {
					TypeElement ie = (TypeElement) e;
					
					GroupModel groupModel = new GroupModel(ie);

					trace("Writing proxy class for " + ie.getQualifiedName());
					

					writeClassFile(filer, groupModel);

					newServiceFileContent.append(groupModel.buildNameModel().getQualifiedName());
					newServiceFileContent.append(System.lineSeparator());

				} else {
					throw new RuntimeException("Not able to handle anything other than an interface currently");
				}

			}

			if (existingServiceFileContent.length() == 0) {
				trace("New " + RELATIVE_NAME + " file created");
				existingServiceFileContent.append("# GENERATED BY THE AndHow AndHowCompileProcessor.");
			}

			try {

				FileObject groupFile = filer.createResource(javax.tools.StandardLocation.SOURCE_OUTPUT,
						SERVICES_PACKAGE, RELATIVE_NAME, globalGroups.toArray(new Element[globalGroups.size()]));

				try (Writer writer = groupFile.openWriter()) {
					writer.write(existingServiceFileContent.toString());
					writer.write(System.lineSeparator());
					writer.write(newServiceFileContent.toString());
				}

			} catch (IOException ex) {
				System.err.println("FAILED TO RUN COMPILE PROCESSOR");
				Logger.getLogger(AndHowCompileProcessor.class.getName()).log(Level.SEVERE, null, ex);
			}

		} else {
			trace("No annotated elements found");
		}

		return true;

	}

	public String generateClassString(String pkgName, String genSimpleName, String causeSimpleName) {
		String templatePath
				= "/" + this.getClass().getCanonicalName().replace(".", "/") + "_Template.txt";

		try {

			InputStream in = AndHowCompileProcessor.class.getResourceAsStream(templatePath);
			if (in == null) {
				throw new Exception("resource not found: " + templatePath);
			}

			StringBuffer buf = new StringBuffer();
			BufferedReader reader = new BufferedReader(new InputStreamReader(in, "UTF-8"));
			String line = reader.readLine();
			while (line != null) {
				buf.append(line).append(System.lineSeparator());
				line = reader.readLine();
			}
			
			reader.close();

			//String template = new String(Files.readAllBytes(Paths.get(getClass().getResource(templatePath).toURI())));
			String source = String.format(buf.toString(),
					genSimpleName,
					pkgName, causeSimpleName,
					GlobalPropertyGroupServiceProxy.class.getCanonicalName(),
					this.getClass().getCanonicalName(), runDate
			);
			return source;
		} catch (Exception ex) {
			error("Error finding or formatting '" + templatePath + "'", ex);
			return null;	//error throws a runtime
		}

	}

	public void writeClassFile(Filer filer, GroupModel causingElement) {

		String genFullName = "";

		try {

			String causeFullName = causingElement.getLeafElement().getQualifiedName().toString();
			String causeSimpleName = causingElement.getLeafElement().getSimpleName().toString();
			String pkgName = causingElement.getPackage().getQualifiedName().toString();
			String genSimpleName = causingElement.buildNameModel().getClassName();
			genFullName = (pkgName.length() > 0) ? pkgName + "." + genSimpleName : genSimpleName;

			String classContent = this.generateClassString(pkgName, genSimpleName, causeSimpleName);

			trace("Writing " + genFullName + " as a generated source file");

			FileObject classFile = filer.createSourceFile(
					genFullName, new Element[]{causingElement.getLeafElement()});

			try (Writer writer = classFile.openWriter()) {
				writer.write(classContent);
			}
		} catch (IOException ex) {
			error("Error attempting to write the generated class file: " + genFullName, ex);
		}
	}

	public static void trace(String msg) {
		System.out.println("AndHowCompileProcessor: " + msg);
	}
	
	public static void error(String msg) {
		error(msg, null);
	}

	public static void error(String msg, Exception e) {
		System.err.println("AndHowCompileProcessor: " + msg);
		throw new RuntimeException(msg, e);
	}
	
	/**
	 * First element is the most leafy enclosed element.
	 */
	public static class ProxyNameModel extends ArrayList<String> {
		private String pkg;
		
		public ProxyNameModel(String pkgName) {
			pkg = pkgName;
		}
		
		public String getPackageName() {
			if (pkg != null) {
				return pkg;
			} else {
				return "";
			}
		}
		
		public String getQualifiedName() {
			if (pkg != null && pkg.length() > 0) {
				return pkg + "." + getClassName();
			} else {
				return getClassName();
			}
		}
		
		public String getClassName() {
			StringBuffer sb = new StringBuffer();
			
			sb.append(GENERATED_CLASS_PREFIX);
			
			for (int i = this.size() - 1; i >=0; i--) {
				sb.append(GENERATED_CLASS_NESTED_SEP).append(this.get(i));
			}
			
			return sb.toString();
		}
	}
	
	/**
	 * First element is the most leafy enclosed element.
	 */
	public static class GroupModel extends ArrayList<TypeElement> {
		private PackageElement pkg;
		
		GroupModel() {
			super();
		}
		
		GroupModel(TypeElement te) {
			super();
			
			add(te);
			Element current = te.getEnclosingElement();
			
			while (current != null) {
				if (current instanceof TypeElement) {
					add((TypeElement)current);
					current = current.getEnclosingElement();
				} else if (current instanceof PackageElement) {
					add((PackageElement)current);
					break;
				} else {
					error("Unexpected nested type '" + current + "' for " + te.getQualifiedName());
				}
			}
		}

		public boolean add(PackageElement e) {
			pkg = e;
			return true;
		}
		
		public PackageElement getPackage() {
			return pkg;
		}
		
		public TypeElement getLeafElement() {
			return get(0);
		}
		
		public ProxyNameModel buildNameModel() {
			ProxyNameModel pnm = new ProxyNameModel(pkg.getQualifiedName().toString());
			
			for (TypeElement te : this) {
				pnm.add(te.getSimpleName().toString());
			}
			
			return pnm;
		}
		
	}

}
